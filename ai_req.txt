type Player struct {
	ID    string      `msg:"id"`
	Name  string      `msg:"name"`
	Color colors.RGBA `msg:"color"`
	JoinedAt time.Time `msg:"joined_at"`
	Status PlayerStatus `msg:"status"`
	HP     float64      `msg:"hp"`
	Kills  int `msg:"kills"`
	Deaths int `msg:"deaths"`
	DeadAt      time.Time `msg:"dead_at"`
	RespawnedAt time.Time `msg:"respawned_at"`
	Position    vector.Vector2D   `msg:"position"`
	Velocity    vector.Vector2D   `msg:"velocity"`
	Angle       float64           `msg:"angle"`
	MoveDir     string            `msg:"move_dir"`
	RotationDir RotationDirection `msg:"turn_dir"`
	Hook       *Hook     `msg:"hook"`
	HookedAt   time.Time `msg:"hooked_at"`
	IsHooked   bool      `msg:"is_hooked"`
	CaughtByID string    `msg:"caught_by_id"`
	Blinking  bool      `msg:"blinking"`
	BlinkedAt time.Time `msg:"blinked_at"`
	Blinked   bool      `msg:"blinked"`
	mu sync.Mutex
}
type Hook struct {
	End             vector.Vector2D `msg:"end"`
	Vel             vector.Vector2D `msg:"vel"`
	CurrentDistance float64         `msg:"current_distance"`
	Stuck           bool            `msg:"stuck"`
	IsReturning     bool            `msg:"is_returning"`
	CaughtPlayerID  string          `msg:"caught_player_id"`
}
func (p1 *Player) UseHook() {
	if p1.Hook != nil && !p1.Hook.IsReturning && p1.Hook.CurrentDistance >= hookMinDistance {
		p1.Hook.IsReturning = true
		return
	}
	if p1.Hook == nil && time.Since(p1.HookedAt).Seconds() >= HookCooldown {
		p1.Hook = &Hook{
			End: vector.NewVector2D(p1.Position.X, p1.Position.Y),
			Vel: vector.NewVector2D(math.Cos(p1.Angle)*hookVelocity, math.Sin(p1.Angle)*hookVelocity),
		}
	}
}
func (p1 *Player) IsHookDone() bool {
	if !p1.Hook.Stuck && !p1.Hook.IsReturning {
		return false
	}
	d := p1.Hook.End.Distance(p1.Position)
	if d < Radius || (p1.Hook.CaughtPlayerID != "" && d < 2*Radius) {
		p1.Hook = nil
		p1.HookedAt = time.Now()
		return true
	}
	return false
}
func (p1 *Player) HookTick(dt float64, players map[string]*Player) {
	if p1.Hook == nil {
		return
	}

	if p1.Hook.Stuck {
		vel := vector.NewVector2D(p1.Hook.End.X, p1.Hook.End.Y)
		vel.SubV(p1.Position)
		vel.Normalize()
		vel.Mul(hookBackwardVelocity)
		p1.Velocity = vel
		p1.Step(dt)

		if p1.IsHookDone() {
			return
		}
	} else {
		target, targetExists := players[p1.Hook.CaughtPlayerID]

		if p1.Hook.IsReturning {
			vel := vector.NewVector2D(p1.Position.X, p1.Position.Y)
			vel.SubV(p1.Hook.End)
			vel.Normalize()
			vel.Mul(hookBackwardVelocity * dt)
			p1.Hook.Vel = vel
			p1.Hook.End.AddV(p1.Hook.Vel)
		} else {
			p1.Hook.End.Add(p1.Hook.Vel.X*dt, p1.Hook.Vel.Y*dt)
			p1.Hook.CurrentDistance += hookVelocity * dt
			if p1.Hook.CurrentDistance >= hookDistance {
				p1.Hook.IsReturning = true
			}
		}

		if !targetExists {
			p1.HookPlayer(players)
			target, targetExists = players[p1.Hook.CaughtPlayerID]
		}

		if targetExists {
			target.Position.X = p1.Hook.End.X
			target.Position.Y = p1.Hook.End.Y
		} else if !p1.Hook.IsReturning {
			p1.Hook.Clamp()
		}

		if p1.IsHookDone() {
			if targetExists {
				target.IsHooked = false
				target.CaughtByID = ""
			}
		}
	}
}